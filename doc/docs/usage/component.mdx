---
sidebar_position: 3
title: Component
---


# Component

React Native Styled System does not create basic components internally.

Instead, you can define the components that will use your theme directly with a simple and extensible API.

The mainly used APIs are as follows.

- `useSx(hook)`
- `SxProps(type)`

## `StyledView` example

Let’s create a component that can use React Native’s `View` component like a Styled System.

How to use the completed `StyledView` component is as follows.

![image.png](https://raw.githubusercontent.com/mym0404/image-archive/master/202403131245340.png)

```tsx
<StyledView w={48} h={48}>
  <StyledView w={'100%'} h={24} radius={12} bg={'red500'} t={0} />
  <StyledView w={24} h={24} radius={12} bg={'blue400'} pos={'absolute'} t={0} r={'-24'} />
  <StyledView w={24} h={24} radius={12} bg={'yellow300'} pos={'absolute'} b={0} r={-24} />
  <StyledView w={24} h={24} radius={12} bg={'violet400'} pos={'absolute'} b={0} r={'-48'} />
  <StyledView w={24} h={24} radius={12} bg={'violet50'} pos={'absolute'} b={0} l={'sidePadding'} />
</StyledView>
```

It can be defined as follows:

```tsx title="StyledView.tsx"
import { forwardRef, Ref, PropsWithChildren } from 'react';
import { View, ViewProps } from 'react-native';
import { SxProps, useSx } from 'react-native-themed-styled-system';

type StyledViewProps = PropsWithChildren<ViewProps & SxProps>;
const StyledView = forwardRef((props: StyledViewProps, ref: Ref<View>) => {
  const { viewStyle } = useSx(props);
  return <View ref={ref} {...props} style={viewStyle()} />;
});

export { StyledView };
export type { StyledViewProps };
```

`useSx` is responsible for receiving `SxProps` and converting it to `ViewStyle`.

You can call the `viewStyle` function returned by `useSx` and pass it to the `style` prop of the desired view.

:::warning
The prop type of a component containing the `SxProps` type includes all the keys included in `SxProps`.

Therefore, if all props from the parent are passed through object destruction like in the existing `{...props}`, the keys do not overlap.
You need to be careful not to do so.
:::

## Example of refactoring an existing component

Let's look at how to refactor existing components as follows.

```tsx
type Props = {
  style?: StyleProp<ViewStyle>;
  title?: string;
  body?: string;
};
const ExistComponent = ({
  style,
  title,
  body,
}: Props) => {
  return (
    <View
      style={[style, { alignItems: 'center', justifyContent: 'center' }]}
    >
...
```

This changes to:

```tsx
type Props = {
  style?: StyleProp<ViewStyle>;
  title?: string;
  body?: string;
//highlight-next-line
} &SxProps;
const ScreenErrorFallback = (props: Props) => {
//highlight-next-line
  const { title, body } = props;
//highlight-next-line
  const { viewStyle } = useSx(props);
  return (
    <View
//highlight-next-line
      style={viewStyle({ alignItems: 'center', justifyContent: 'center' })}
      pointerEvents={'box-none'}
    >
```

There are a few things to keep in mind.

1. `useSx` includes `props.style` in the automatically created style output.
There is no need to add `style` as a prop to `style` of `View`.
2. Always pass all `props` objects themselves to `useSx` to avoid missing any properties. `useSx`
Properties that are not used internally are ignored and not changed.
3. `viewStyle` can receive `SxProps` as an argument and consider it in the result.

## Multiple ways to convey styles and parsing priorities

There are various ways in which `useSx` is used to parse styles and produce output.

Let's say Props looks like this:

```tsx
const props = {
  style: { marginTop: 24 }, // 1
  mt: '24px', // 2
  sx: { mt: '24px' }, // 3
}
```

1. Props’ `style` prop
2. Styles of `SxProps`, such as `ml` and `w` of Props
3. Styles inside the `sx` prop of Props
4. First argument of `viewStyle(sx?: SxProps)`

**The priority is calculated as 1 > 3 > 2 > 4.**

1 has the highest priority.