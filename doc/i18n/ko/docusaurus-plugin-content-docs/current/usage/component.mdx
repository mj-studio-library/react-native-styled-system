---
sidebar_position: 3
title: 컴포넌트
---


# 컴포넌트

React Native Styled System는 내부적으로 기본 Component를 만들어두지 않았습니다.

대신, **단순하고 확장가능한 API로 직접 테마를 사용할 컴포넌트를 정의**할 수 있습니다.

주로 쓰는 API는 다음과 같습니다.

- `useSx(hook)`
- `SxProps(type)`

## `StyledView` 예시

React Native의 `View` 컴포넌트를 Styled System처럼 사용할 수 있는 컴포넌트를 만들어봅시다.

완성된 `StyledView` 컴포넌트의 사용법은 다음과 같습니다.

![image.png](https://raw.githubusercontent.com/mym0404/image-archive/master/202403131245340.png)

```tsx
<StyledView w={48} h={48}>
  <StyledView w={'100%'} h={24} radius={12} bg={'red500'} t={0} />
  <StyledView w={24} h={24} radius={12} bg={'blue400'} pos={'absolute'} t={0} r={'-24'} />
  <StyledView w={24} h={24} radius={12} bg={'yellow300'} pos={'absolute'} b={0} r={-24} />
  <StyledView w={24} h={24} radius={12} bg={'violet400'} pos={'absolute'} b={0} r={'-48'} />
  <StyledView w={24} h={24} radius={12} bg={'violet50'} pos={'absolute'} b={0} l={'sidePadding'} />
</StyledView>
```

다음과 같이 정의할 수 있습니다.

```tsx title="StyledView.tsx"
import { forwardRef, Ref, PropsWithChildren } from 'react';
import { View, ViewProps } from 'react-native';
import { SxProps, useSx } from 'react-native-themed-styled-system';

type StyledViewProps = PropsWithChildren<ViewProps & SxProps>;
const StyledView = forwardRef((props: StyledViewProps, ref: Ref<View>) => {
  const { viewStyle } = useSx(props);
  return <View ref={ref} {...props} style={viewStyle()} />;
});

export { StyledView };
export type { StyledViewProps };
```

`useSx`는 `SxProps`를 받아 이를 `ViewStyle`로 변환하는 역할을 합니다.

`useSx`가 반환하는 `viewStyle` 함수를 호출해 원하는 뷰의 `style` prop에 전달할 수 있습니다.

:::warning
`SxProps` 타입을 포함한 컴포넌트의 prop type은 `SxProps`에 포함되는 키들이 모두 포함됩니다.

따라서 기존에 `{...props}` 처럼 object destruction을 통해 부모로부터의 prop이 모두 전달되는 경우 키가 겹치지
않는지 주의가 필요합니다.
:::

## 기존 컴포넌트를 리팩터링하는 예시

다음과 같이 기존에 있던 컴포넌트를 리팩터링 하는 방식을 살펴보겠습니다.

```tsx
type Props = {
  style?: StyleProp<ViewStyle>;
  title?: string;
  body?: string;
};
const ExistComponent = ({
  style,
  title,
  body,
}: Props) => {
  return (
    <View
      style={[style, { alignItems: 'center', justifyContent: 'center' }]}
    >
...
```

이는 다음과 같이 변합니다.

```tsx
type Props = {
  style?: StyleProp<ViewStyle>;
  title?: string;
  body?: string;
// highlight-next-line
} & SxProps;
const ScreenErrorFallback = (props: Props) => {
// highlight-next-line
  const { title, body } = props;
// highlight-next-line
  const { viewStyle } = useSx(props);
  return (
    <View
// highlight-next-line
      style={viewStyle({ alignItems: 'center', justifyContent: 'center' })}
      pointerEvents={'box-none'}
    >
```

눈여겨 볼 점이 몇가지 있습니다.

1. `useSx`는 `props.style`도 자동으로 만들어지는 style의 결과물에 포함하기 때문에
`View`의 `style`에 prop으로 들어온 `style`도 같이 넣어줄 필요가 없습니다.
2. 누락되는 속성이 없게 항상 모든 `props` 객체 자체를 `useSx`로 넘기도록 합니다. `useSx`는
내부적으로 쓰이지 않는 속성들은 무시하고 변경시키지 않습니다.
3. `viewStyle`은 `SxProps`를 인자로 받아 결과에 고려시킬 수 있습니다.

## 스타일을 전달하는 여러방법과 파싱 우선순위

`useSx`가 스타일을 파싱하고 결과물을 산출하는데 사용되는 방식은 다양합니다.

Props이 다음과 같이 생겼다고 해보겠습니다.

```tsx
const props = {
  style: { marginTop: 24 }, // 1
  mt: '24px', // 2
  sx: { mt: '24px' }, // 3
}
```

1. Props의 `style` prop
2. Props의 `ml`, `w` 같은 `SxProps`의 스타일들
3. Props의 `sx` prop 내부의 스타일들
4. `viewStyle(sx?: SxProps)`의 첫 인자

**이에 따른 우선순위는 1 > 3 > 2 > 4 로 계산됩니다.**

1이 가장 우선순위가 높습니다.